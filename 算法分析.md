# 1, 图

## 1，图的连通性于图的遍历

### 1， 宽度优先搜索(BFS)

> 我们从s向外在所有可能的方向上探查，一次增加一"层"结点，于是，我们从s开始，包含所有通过一条边与s相交的结点----这就是一层搜索，然后我们包含通过一条边与第一层中任一结点相交的所有新增的结点----这就是第二层，我们继续照这中方式下去直到不再遇到新的结点为止

#### 1， 定理

1. 对每个j>=1，有BFS产生的层L<sub>j</sub>恰好由所有到s距离为j的结点组成，存在一条从s到t的路径当且仅当t出现在某一层<br>
2.  设T是一棵宽度有优先搜索树，设x和y是T中分别属于L<sub>i</sub>和L<sub>j</sub>的结点，并且设(x,y)是G的一条边，那么i与j至多差1

#### 2， 执行BFS算法，产生宽度优先搜索树实例

  ![宽度优先搜索实例](https://thumbnail0.baidupcs.com/thumbnail/5061ccf4202d576c831bf9a0b797915d?fid=2374651070-250528-827240857034616&time=1504612800&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-ByzZYvS1IG9GiscwXe9sZJlESTE%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=5748726461946087984&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)

  1.  从结点1开始，层L<sub>1</sub>由结点2,3组成

  2.  然后通过按顺序（比如说先是2，然后是3）考虑在层L<sub>1</sub>中的结点而产生层L<sub>2</sub>.于是，只要我们看到2，就发现4和5,2成为他们的父亲。当考虑结点2的时候，我们也发现一条通向3的边，但是这条边并不加到BFS树中，因为我们已经知道了结点3。当我们看到结点3的时候首先发现结点7和8，另一方面，从3到5的边是G中另一条不出现在BFS树中的边，因为在见到来自结点3的这条边的时刻，我们已经知道了结点5

  3.  然后我们按次序考虑在层L<sub>2</sub>的结点，但是当我们检查L<sub>2</sub>时，只有一个新的结点被发现，就是结点6，把它加到层L<sub>3</sub>，注意边(4,5)和(7,8)不加到这棵BFS树中，因为它们没有导致新结点的发现

  4.  当检查结点6时没有发现新节点，因此没有结点放在层L<sub>4</sub>，算法结束。整个的BFS树被画在上图

### 2， 深度优先搜索(DFS)

# 2， 树

> 一个无向图如果是连通的，且不包含一个圈，我们就说它是一棵树

- 命题

> 每棵n个节点的树恰好有n-1条边

- 定理

> 设G是具有n个结点的无向图，下面任意两个语句都可以推出第三个语句<br>
> (1) G是连通的<br>
> (2) G不包含一个圈<br>
> (3) G有n-1条边
