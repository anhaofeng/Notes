# 1, 算法

## 1， 算法的重要特征

1.  有穷性：保证执行有限步骤之后结束

2.  确切性：每一步骤都有确切的定义

3.  输入：每个算法有一个或多个输入，以刻画运算对象的初始情况。所谓零个输入是指算法本身舍弃了初始条件

4.  输出：每个算法有一个或多个输出，显示对应输入数据加工后的结果。没有输出的算法是毫无意义的

5.  可行性：在原则上算法能够精确地运行，进行有限次运算即可完成一次运算

# 2, 图

## 1，图的连通性于图的遍历


### 1， 宽度优先搜索(BFS)

> 我们从s向外在所有可能的方向上探查，一次增加一"层"结点，于是，我们从s开始，包含所有通过一条边与s相交的结点----这就是一层搜索，然后我们包含通过一条边与第一层中任一结点相交的所有新增的结点----这就是第二层，我们继续照这中方式下去直到不再遇到新的结点为止

#### 1， 定理

1. 对每个j>=1，有BFS产生的层L<sub>j</sub>恰好由所有到s距离为j的结点组成，存在一条从s到t的路径当且仅当t出现在某一层<br>
2.  设T是一棵宽度有优先搜索树，设x和y是T中分别属于L<sub>i</sub>和L<sub>j</sub>的结点，并且设(x,y)是G的一条边，那么i与j至多差1

#### 2， 执行BFS算法，产生宽度优先搜索树实例

 ![宽度优先搜索实例](https://github.com/dragonhht/GitImgs/blob/master/DataStructures/Graph/BFS.png?raw=true)

  1.  从结点1开始，层L<sub>1</sub>由结点2,3组成

  2.  然后通过按顺序（比如说先是2，然后是3）考虑在层L<sub>1</sub>中的结点而产生层L<sub>2</sub>.于是，只要我们看到2，就发现4和5,2成为他们的父亲。当考虑结点2的时候，我们也发现一条通向3的边，但是这条边并不加到BFS树中，因为我们已经知道了结点3。当我们看到结点3的时候首先发现结点7和8，另一方面，从3到5的边是G中另一条不出现在BFS树中的边，因为在见到来自结点3的这条边的时刻，我们已经知道了结点5

  3.  然后我们按次序考虑在层L<sub>2</sub>的结点，但是当我们检查L<sub>2</sub>时，只有一个新的结点被发现，就是结点6，把它加到层L<sub>3</sub>，注意边(4,5)和(7,8)不加到这棵BFS树中，因为它们没有导致新结点的发现

  4.  当检查结点6时没有发现新节点，因此没有结点放在层L<sub>4</sub>，算法结束。整个的BFS树被画在上图

### 2， 深度优先搜索(DFS)

> 图G是一个互相连通的，从s开始并且尝试第一条从s出发的边，到另一个结点v，然后沿着从v出发的第一条边出来，以这种方式继续下去，知道找到一个死结点。然后回溯直到到达有尚未被探查邻居的一个结点，并且从此处重新开始

#### 1， 定理

1.  设T是一棵深度优先搜索树，x与y是T中的结点，且(x,y)是G中不属于T的一条边，那么x或y之中一个是另一个的祖先

## 2、用优先队列与栈实现图的遍历

- G1(有向图)

![](https://github.com/dragonhht/GitImgs/blob/master/DataStructures/Graph/DirectedGraph_G1.png?raw=true)

- G2(无向图)

![](https://github.com/dragonhht/GitImgs/blob/master/DataStructures/Graph/DirectedGraph_G1.png?raw=true)

### 1、图的存储结构

#### 1、邻接矩阵表示法

> 也称作数组的表示法。它采用两个数组来表示图；一个是用来存顶点信息的以为数组，另一个是用于存储图中顶点之间关联关系的二维数组，这个关联关系数组被被称为邻接矩阵。

---

- 若G是一具有n个顶点的无权图，G的邻接矩阵是具有如下性质的n*n的矩阵A:

![](https://github.com/dragonhht/GitImgs/blob/master/DataStructures/Graph/AdjacencyMath_0.png?raw=true)

---

- G1 、G2的邻接矩阵图:

![](https://github.com/dragonhht/GitImgs/blob/master/DataStructures/Graph/AdjacencyMatrix.png?raw=true)

# 3， 树

> 一个无向图如果是连通的，且不包含一个圈，我们就说它是一棵树

- 命题

> 每棵n个节点的树恰好有n-1条边

- 定理

> 设G是具有n个结点的无向图，下面任意两个语句都可以推出第三个语句<br>
> (1) G是连通的<br>
> (2) G不包含一个圈<br>
> (3) G有n-1条边


# 4， 八大算法思想

## 1, 枚举

> 在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么该结论是可靠的，那种归纳方法叫做枚举

### 1， 枚举算法基础

枚举一般使用while循环实现

- 枚举算法解题的基本思路

  1.  确定枚举对象，枚举范围和判定条件

  2.  逐一枚举可能的解，验证每个解是否是问题的解

- 一般步骤

  1.  解题的可能范围，不能遗漏任何一个真正的解，也要避免重复

  2.  判断是否是真正的解的方法

  3.  是可能的解的范围缩小至最小，以便提高解决问题的效率

### 2, 运用枚举法是需要面对的问题

| 特点及要求 | 可能出现的问题 |
| ------------- | :-------------: |
| 选取考察对象 | 选取的考察对象不恰当 |
| 逐个考察所有可能的情况 | 没有“逐个”考察，不恰当地遗漏了一些情况;没有考察“所有”，对空间集的确定失误 |
| 选取判断标准 | 判断标准“不正确”，导致结果错误；判断标准“不全面”，导致结果错误或得到结果的效率下降；判断标准“不高效”，意味着没有足够地剪枝 |

### 3， 缺点

> 运算量较大，解题效率不高

---

## 2, 递推

> 通过在已知的某个条件，利用特定的关系得到中间的推论，然后逐步递推，知道结果为止

### 1， 递推算法基础

- 顺推法：从已知条件出发，逐步推算出要解决问题的方法。

- 逆推法：从已知的结果出发，用迭代表达式推算出问题开始的条件

---

## 3， 递归

### 1, 递归算法基础

- 特点

  1.  递归过程一般通过函数或子函数过程来实现

  2.  递归算法在函数或子过程的内部，直接或间接地调用自己的算法

  3.  递归算法实际上是吧问题转化为规模缩小了的同类问题的子问题，然后在递归调用函数或过程来表示问题的解

- 注意点

  1.  递归是在过程或函数中调用自身的过程

  2.  在使用递归策略时，必须有一个明确的递归条件，这称为递归出口

  3.  递归算法通常显得简洁，但是运行效率较低，所以一般不提倡递归算法设计程序

  ### 2， 递归与递推的差异

  > 递推像是多米诺骨牌，根据前面几个得到后面的；递归是大事化小；如果一个问题的求解既可以递归算法求解，也可以递推算法求解，此时往往选择用递推算法，因为递推的效率比递归高

  ---

  ## 4， 分治

  > 将一个规模为N的问题分解为K个规模较小的子问题，这些问题相互独立且与原问题性质相同。

  ### 1， 分治算法基础

  - 一般步骤

    1.  分解：将要解决的问题划分为若干个规模较小的同类问题

    2.  求解：当子问题划分的足够小时，用较简单的方法解决

    3.  合并：按原问题的要求，将子问题的解逐层合并构成原问题的解

