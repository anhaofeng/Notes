# 一、Java虚拟机的基本结构

![JVM基本结构](https://github.com/dragonhht/GitImgs/blob/master/Notes/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png?raw=true)

- 类加载器子系统：负责从文件系统或者网络中记载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时的常量池信息，包含字符串字面量和数字常量（这部分常量信息是Class文件中常量吃部分的内存映射）
- Java堆在虚拟机启动的时候建立，他是Java程序最主要的内存工作区域。几乎所有Java对象实例都存放于Java堆中。堆空间是所有线程共享的，这是一块与Java应用密切相关的内存区间
- Java的NIO库允许Java程序使用直接内存。直接内存是Java堆外的、直接向系统申请的内存区间。通常，访问直接内存的速度优于Java堆。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在Java堆外，因此他的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存
- 垃圾回收系统是Java虚拟机的重要组成部分，垃圾回收器可以对方法区、Java堆和直接内存进行回收。其中，Java堆是垃圾回收器的工作重点。和C/C++不同，Java中所有的对象空间释放都是隐式的。也就是说，Java中没有类似free()和delete()这样的函数释放指定的内存区域，对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成Java堆、方法区和直接内存中的全自动管理。
- 每一个Java虚拟机线程都有一个私有的Java栈。一个线程的Java栈在线程创建的时候被创建。Java栈中保存着帧信息，Java栈中保存着局部变量、方法参数，同时和Java方法的调用、返回密切相关。
- 本地方法栈和Java栈非常类似，最大的不同在于Java栈用于Java方法的调用，而本地方法栈则用于本地方法调用。作为Java虚拟机的重要扩展，Java虚拟机允许Java直接调用本地方法。
- PC寄存器也是每个线程私有的空间，Java虚拟机会为每一个Java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是一个本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined。
- 执行引擎是Java虚拟机的最核心组件之一，它负责执行虚拟机的字节码。


## 1、Java堆

Java堆是和Java应用程序关系最为密切的内存空间，几乎所有的对象都存放于堆中。并且堆是完全自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，而不需要显示地释放。

Java堆一般结构如下所示。

![Java堆一般结构](https://github.com/dragonhht/GitImgs/blob/master/Notes/Java%E5%A0%86%E7%A9%BA%E9%97%B4%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84.png?raw=true)

在绝大部分情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存活，则会进入s0或s1，之后，没经过一次新生代回收，对象如果存活，它的年龄机会加1，当对象的年龄达到一定条件后，就会被认为是老年对象，从而进入老年代。

## 2、Java栈

Java栈是一块线程私有的内存空间。如果说，Java栈和程序数据密切相关，那么Java栈就是和线程执行密切相关的。线程执行的基本行为是函数调用，每次函数调用的数据就是通过Java栈传递的。

![Java栈](https://github.com/dragonhht/GitImgs/blob/master/Notes/%E6%A0%88%E5%B8%A7%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png?raw=true)

Java栈与数据结构上的栈有着类似的含义，他是一块先进先出的数据结构，只支持出栈和入栈两种操作。在Java栈中保存的主要内容为栈帧。每一次函数调用，都会有一个对应的栈帧被压入Java栈，每一个函数调用结束，都会有一个栈帧被弹出Java栈。

当函数返回时，栈帧从Java栈中被弹出。Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。

在一个栈帧中，至少要包含局部变量表、操作数栈和帧数据。



# 二、类的加载

## 1、ClassLoader的分类

- BootStrap ClassLoader(启动类加载器)：一般负责加载系统的核心类，如，rt.jar中的Java类
- Extendsion ClassLoader(扩展类加载器)：用于加载%JAVA_HOME%/lib/ext/*.jar中的Java类
- App ClassLoader(应用类加载器，系统类加载器)：用于加载用户程序的类
- 自定义的ClassLoader：加载一些特殊途径的类，一般也是用户类

![JavaClassLoader](https://github.com/dragonhht/GitImgs/blob/master/Notes/JavaClassLoader.png?raw=true)

